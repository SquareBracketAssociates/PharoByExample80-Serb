{ "title": "Sintaksa ukratko" }
@cha:syntax

Pharo je usvojio sintaksu koja je veoma bliska sintaksi njenog prethodnika, Smalltalk-a. Sintaksa je dizajnirana tako da tekst može biti pročitan naglas tako da zvuči skoro kao Engleski. Sledeći metod klase ==Week== prikazuje primer sintakse. On proverava da li ==DayNames== već sadrži argument, tj.
da li argument predstavlja ispravno ime dana. Ako je to slučaj, dodeliće ga promenljivoj ==StartDay==.

[[[
startDay: aSymbol

   (DayNames includes: aSymbol)
      ifTrue: [ StartDay := aSymbol ]
      ifFalse: [ self error: aSymbol, ' is not a recognised day name' ]
]]]

Pharo sintaksa je minimalna. U suštini, postoji samo sintaksa za slanje poruka
(tj. izrazi). Izrazi se grade od veoma malog broja primitivnih elemenata (slanje poruka, dodela, zatvaranje bloka (''eng. block closure''), vraćanje (''eng. return''),.... Postoji samo 6 klučnih reči, takozvanih pseudo-promenljivih i ne postoji sintaksa za kontrolne strukture ili declarisanje novih klasa. Umesto toga, skoro sve se postiže slanjem poruka objektima. Na primer, umesto if-then-else kontrolne strukture, uslovni izrazi su poruke (kao što je ==ifTrue:==) poslate objektima klase Boolean. Nove (pod-)klase se kreiraju slanjem poruke njihovim superklasama.

!!! Elementi sintakse

Izrazi se grade od sledećih  elemenata:

# Šest ''pseudo-promenljivih'': ==self==, ==super==, ==nil==, ==true==, ==false==, i ==thisContext==
# Konstantni izrazi za ''literale'', konkretne objekte, uključujući brojeve, karaktere, stringove, simbole i nizove
# Deklaracije promenljivih
# Dodele
# Zatvaranja blokova
# Poruke
# Vraćanje rezultata iz metoda

Pogledajmo primere različitih elemenata sintakse u tabeli ispod.

|!Sintaksni izraz |!Šta predstavlja
|==startPoint== | ime promenljive
|==Transcript== | ime globalne promenljive
|self | pseudo-promenljiva
|==1 ==| decimali ceo broj
|==2r101== | binarni ceo broj
|==1.5== | broj sa plivajućom tačkom
|==2.4e7== | broj u exponencialnoj notaciji
|==$a== | karakter =='a'==
|=='Hello'== | string =='Hello'==
|==#Hello== | simbol ==#Hello==
|==#(1 2 3)== | literal niz
| =={ 1 . 2 . 1 + 2 }== | dinamički niz
|=="a comment"== | komentar
|==\| x y \|==| deklaracija promenljivih ==x== i ==y==
|==x := 1==| dodela: 1 dodeljuje promenljivoj ==x==
|==[:x \| x + 2 ]==| blok čija je vrednost ==x + 2==
|==<primitive: 1>==| primitivne operacije vitruelne mašine ili anotacije
|==3 factorial==| unarna poruka ==factorial==
|==3 + 4==| binarna poruka ==+==
|==2 raisedTo: 6 modulo: 10==| poruka sa ključnim rečima ==raisedTo:modulo:==
|==^ true==| vraća vrednost true
|==x := 2 . x := x + x==| dva izaza razdvojena separatorom (==.==)
|==Transcript show: 'hello'; cr==| dve kaskadne poruke razdvojene separatorom (==;==)

""Localne promenljive."" ==startPoint== je ime promenljive, ili identifikator. Prema konvenciji, identifikatori su sastavljeni od reči  u "camelCase" formatu (tj. svaka reč izuzev prve počinje velikim slovom). Prvo slovo promenljive instance, parametra metoda ili bloka, ili privremene promenljive mora biti malo slovo. Ovo ukazuje čitaocu da promenjlive imaju privatan opseg vidljivosti.

""Deljene promenljive."" Identifikatori koji počinju velikim slovom letters su globalne promenljive, promenljive klase, objedinjeni rečnik ili imena klasa. ==Transcript== je globalna promenljiva, instanca klase ==ThreadSafeTranscript==.

""Aktuelni objekat."" ==self== je pseudo-promenljiva koja se odnosi na tekući objekat i daje nam način da mu pošaljemo poruku. Kako je tekući objekat onaj unutar kog se trenutni metod izvršava, možemo ga zvati i "primaoc" jer će ovaj objekat primiti poruku što će dovesti do izvršavanja metoda. Konačno, ==self== se zove "pseudo-promenljiva" jer mu ne možemo dodeliti vrednost.

""Celi brojevi"" ''(eng. Integers.)'' Pored uobičajenih decimalnih celih brojeva kao što je 42, u Pharo-u možemo koristiti i ''radix'' notaciju. ==2r101== je 101 sa osnovom 2 (tj., binarno), što je jednako decimalnom 5.

""Brojevi sa plivajućom tačkom."" mogu biti zapisani eksponencijalno sa osnovom 10: ==2.4e7== je ==2.4 X 10^7==.

""Karakteri."" Znak za dolar, $, uvodi literal karakter: ==$a== je literal za karakter =='a'==. Instance specijalnih karaktera koji se ne štampaju mogu biti pribavljene slanjem odgovarajućih, prigodno imenovanih poruka, kao što su ==Character space== i ==Character tab==, klasi ==Character==.

""Stringovi."" Jednostruki navodnici ==' '== se koriste za definisanje string literala. Ao želite string koji sadrži jednostruke navodnike u sebi, samo duplirajte navodnik, kao u
=='G'\'day'==.

""Simboli."" Simboli su kao Stringovi, u smislu da predstavljaju sekvencu karaktera. HIpak, za razliku od stringova, simbol literali su garantovano jedinstveni na globalnom nivou. Postoji samo jedan objekat  ==#Hello== klase ==Symbol==, dok može postojati više objekata klase ==String== koji imaju vrednost =='Hello'==.

""Nizovi literali u vreme kompajliranja."" Definišu se sa ==#( )== unutar čega su navedeni literali razdvojeni razmakom. Sve unutar zagrada mora biti konstanta u vreme kompajliranja. Na primer, ==#(27 (true false) abc)== je niz literal sa tri elementa: ceo broj 27, literalni niz koji sadrži dve pseudo-promenljive, nepromenljive objekte klase Boolean, i simbol ==#abc==. Primetimo da je ovo isto kao ==#(27 #(true false) #abc)==.

""Dinamički nizovi u vreme izvršavanja."" Vitičaste zagrade =={ }== definišu dinamičke nizove čiji se elementi su izrazi odvojeni tačkom i koji se izračunavaju u vreme izvršavanja. Dakle,  =={ 1. 2. 1 + 2 }== definiše niz čiji su elementi 1, 2, i rezultat izračunavanja ==1+2==.

""Komentari."" Navode se unutar dvostrukih navodnika \" \". "Hello" je komentar,a ne String, i ignoriše se od strane Pharo compajlera. Komentari se mogu prostirati preko više linija.

""Definicije lokalnih promenljivih."" Vertikalne crte ==| |== ograničavaju definiciju jedne ili više lokalnih promenljivih pre početka tela metoda ili bloka.

""Dodela."" ==:= == dodeljuje objekat promenljivoj.

""Blokovi."" Unutar uglastih zagrada ==[ ]== definišemo blokove, koji su takođe poznati kao zatvaranje bloka ''eng. block
closure'' ili leksičko zatvaranje ''eng. lexical closure''. To su objekti prve klase koji predstavljaju funkcije. Kao što ćemo videti, blokovi mogu imati argumente (==[:i | ...]==) i lokalne promenljive (==[| x | ...]==) .

""Primitivne operacije."" ==< primitive: ... >== označava  poziv primitivne operacije virtuelne mašine (VM). Na primer, ==< primitive: 1 >== je primitivna operacija VM za ==SmallInteger==. Bilo koji kod koji sledi iza primitivne operacije izvršava se samo ako primitivna operacija ne uspe. Ista sintaksa poruke unutar ==< >== se takođe koristi za druge vrste anotacije metoda (''eng. pragma'').

""Unarne poruke."" One se satoje od samo jedne reči (kao što je ==factorial==) poslate primaocu (kao što je 3). U ==3 factorial==, 3 je primaoc, a ==factorial== je selektor poruke.

""Binarne poruke."" To su poruke koje se šalju primaocu sa samo jednim argumentom i čiji selektor izgleda kao matematički operator (na primer: ==\+==). U ==3 + 4==, primaoc je 3, selector poruke je ==\+==, a argument je 4.

""Poruke sa ključnim rečima."" Njihov selektor se sastoji od jedne ili više ključnih reči (npr. ==raisedTo:
modulo:==), od kojih se svaka završava s advotačkom i uzima tačno argument. U izrazu ==2 raisedTo: 6 modulo: 10==, selektor poruke
==raisedTo:modulo:== prima dva argumenta, 6 i 10, od kojih se svaki navodi iza odgovarajuće dvotačke. Ova poruka se šalje primaocu 2.

""Vraćanje vrednosti izračunavanja metoda."" ==^== se koristi da ''vrati'' vrednost iz metoda.

""Sekvenca naredbi."" Tačka (==.==) je separator naredbi. Stavljanjem tačke izmedju dva izraza učiniće ih nezavisnim naredbama.

""Kaskade."" Tačka-zarez ( ==;== ) se može koristiti da se pošalje kaskada poruka jednom primaocu. U  ==Transcript show: 'hello'; cr== prvo šaljemo poruku sa ključnim rečima
 ==show: 'hello'== primaocu ==Transcript==, a zatim šaljemo unarnu poruku ==cr== istom primaocu.

Vrste i načini slanja poruka su detaljnije objašnjeni u Glavi *: Razumevanje sintakse poruka>../UnderstandingMessage/UnderstandingMessage.pier@chapterUnderstandingMessage*, a Klase ==Number==, ==Character==, ==String== i ==Boolean== u Glavi *: Osnovne klase>../BasicClasses/BasicClasses.pier@cha:basicClasses*.

!!!Pseudo-variables

In Pharo, there are 6 reserved keywords, or pseudo-variables: ==nil==, ==true==,
==false==, ==self==, ==super==, and ==thisContext==. They are called
pseudo-variables because they are predefined and cannot be assigned to.
==true==, ==false==, and ==nil== are constants, while the values of ==self==,
==super==, and ==thisContext== vary dynamically as code is executed.

- ==true== and ==false== are the unique instances of the Boolean classes ==True== and ==False==. See Chapter *: Basic Classes>../BasicClasses/BasicClasses.pier@cha:basicClasses* for more details.

- ==self== always refers to the receiver of the currently executing method.

- ==super== also refers to the receiver of the current method, but when you send a message to ==super==, the method-lookup changes so that it starts from the superclass of the class containing the method that uses ==super==. For further details see Chapter *: The Pharo Object Model>../PharoObjectModel/PharoObjectModel.pier@cha:model*.

- ==nil== is the undefined object. It is the unique instance of the class ==UndefinedObject==. Instance variables, class variables and local variables are initialized to ==nil==.

- ==thisContext== is a pseudo-variable that represents the top frame of the execution stack. ==thisContext== is normally not of interest to most programmers, but it is essential for implementing development tools like the debugger, and it is also used to implement exception handling and continuations.

!!!Message sends

There are three kinds of messages in Pharo. This distinction has been made to
reduce the number of mandatory parentheses.

#''Unary'' messages take no argument. ==1 factorial== sends the message ==factorial== to the object 1.
#''Binary'' messages take exactly one argument. ==1 \+ 2== sends the message ==\+== with argument 2 to the object 1.
#''Keyword'' messages take an arbitrary number of arguments. ==2 raisedTo: 6 modulo: 10== sends the message consisting of the message selector ==raisedTo:modulo:== and the arguments 6 and 10 to the object 2.

!!!!!Unary messages.
Unary message selectors consist of alphanumeric characters, and start with a
lower case letter.

!!!!!Binary messages.
Binary message selectors consist of one or more characters from the following
set:

[[[
+ - / \ * ~ < > = @ % | & ? ,
]]]

!!!!!Keyword message selectors.
Keyword message selectors consist of a series of alphanumeric keywords, where
each keyword starts with a lower-case letter and ends with a colon.

!!!!!Message precedence.
Unary messages have the highest precedence, then binary messages, and finally
keyword messages, so:

[[[testcase=true
2 raisedTo: 1 + 3 factorial
>>> 128
]]]

First we send ==factorial== to 3, then we send ==\+ 6== to 1, and finally we
send ==raisedTo: 7== to 2. Recall that we use the notation expression ==>>>==
to show the result of evaluating an expression.

Precedence aside, execution is strictly from left to right, so:

[[[testcase=true
1 + 2 * 3
>>> 9
]]]

return 9 and not 7. Parentheses must be used to alter the order of evaluation:

[[[testcase=true
1 + (2 * 3)
>>> 7
]]]

!!!!!Periods and semi-colons.
Message sends may be composed with periods and semi-colons. A period separated
sequence of expressions causes each expression in the series to be evaluated as
a ''statement'', one after the other.

[[[
Transcript cr.
Transcript show: 'hello world'.
Transcript cr
]]]

This will send ==cr== to the ==Transcript== object, then send it ==show: 'hello
world'==, and finally send it another ==cr==.

When a series of messages is being sent to the ''same'' receiver, then this can
be expressed more succinctly as a ''cascade''. The receiver is specified just
once, and the sequence of messages is separated by semi-colons:

[[[
Transcript
  cr;
  show: 'hello world';
  cr
]]]

This has precisely the same effect as the previous example.

!!!Method syntax

Whereas expressions may be evaluated anywhere in Pharo (for example, in a
playground, in a debugger, or in a browser), methods are normally defined in a
browser window, or in the debugger. Methods can also be filed in from an
external medium, but this is not the usual way to program in Pharo.

Programs are developed one method at a time, in the context of a given class. A
class is defined by sending a message to an existing class, asking it to create
a subclass, so there is no special syntax required for defining classes.

Here is the method ==lineCount== in the class ==String==. The usual
''convention'' is to refer to methods as ==ClassName>>methodName==. Here the
method is then ==String>>lineCount==. Note that ==ClassName>>methodName== is not
part of the Pharo syntax just a convention used in books to clearly define a
method.

[[[
String >> lineCount
	"Answer the number of lines represented by the receiver, where every cr adds one line."

	| cr count |
	cr := Character cr.
	count := 1 min: self size.
	self do: [:c | c == cr ifTrue: [count := count + 1]].
	^ count
]]]

Syntactically, a method consists of:

#the method pattern, containing the name (i.e., ==lineCount==) and any arguments (none in this example)
#comments (these may occur anywhere, but the convention is to put one at the top that explains what the method does)
#declarations of local variables (i.e., ==cr== and ==count==); and
#any number of expressions separated by dots (here there are four)

The execution of any expression preceded by a ==^== (a caret or upper
arrow, which is Shift-6 for most keyboards) will cause the method to exit at
that point, returning the value of that expression. A method that terminates
without explicitly returning some expression will implicitly return ==self==.

Arguments and local variables should always start with lower case letters. Names
starting with upper-case letters are assumed to be global variables. Class
names, like ==Character==, for example, are simply global variables referring to
the object representing that class.

!!!Block syntax

Blocks (lexical closures) provide a mechanism to defer the execution of
expressions. A block is essentially an anonymous function with a definition
context. A block is executed by sending it the message ==value==. The block
answers the value of the last expression in its body, unless there is an
explicit return (with ^) in which case it returns the value of the returned
expression.

[[[testcase=true|language=smalltalk
[ 1 + 2 ] value
>>> 3
]]]


[[[testcase=true|language=smalltalk
[ 3 = 3 ifTrue: [ ^ 33 ]. 44 ] value
>>> 33
]]]

Blocks may take parameters, each of which is declared with a leading colon. A
vertical bar separates the parameter declaration(s) from the body of the block.
To evaluate a block with one parameter, you must send it the message value: with
one argument. A two-parameter block must be sent ==value:value:==, and so on, up
to 4 arguments.

[[[testcase=true|language=smalltalk
[ :x | 1 + x ] value: 2
>>> 3
]]]
[[[testcase=true
[ :x :y | x + y ] value: 1 value: 2
>>> 3
]]]

If you have a block with more than four parameters, you must use
==valueWithArguments:== and pass the arguments in an array. (A block with a
large number of parameters is often a sign of a design problem.)

Blocks may also declare local variables, which are surrounded by vertical bars,
just like local variable declarations in a method. Locals are declared after any
arguments:

[[[testcase=true|language=smalltalk
[ :x :y |
	| z |
	z := x + y.
	z ] value: 1 value: 2
>>> 3
]]]

Blocks are actually lexical closures, since they can refer to variables of the
surrounding environment. The following block refers to the variable ==x== of its
enclosing environment:

[[[testcase=true
| x |
x := 1.
[ :y | x + y ] value: 2
>>> 3
]]]

Blocks are instances of the class ==BlockClosure==. This means that they are
objects, so they can be assigned to variables and passed as arguments just like
any other object.

!!!Conditionals and loops in a nutshell

Pharo offers no special syntax for control constructs. Instead, these are
typically expressed by sending messages to booleans, numbers and collections,
with blocks as arguments.


!!! Some conditionals
Conditionals are expressed by sending one of the messages ==ifTrue:==,
==ifFalse:== or ==ifTrue:ifFalse:== to the result of a boolean expression. See
Chapter *: Basic Classes>../BasicClasses/BasicClasses.pier@cha:basicClasses*,
for more about booleans.

[[[testcase=true
(17 * 13 > 220)
	ifTrue: [ 'bigger' ]
	ifFalse: [ 'smaller' ]
>>>'bigger'
]]]

!!! Some loops
Loops are typically expressed by sending messages to blocks, integers or
collections. Since the exit condition for a loop may be repeatedly evaluated, it
should be a block rather than a boolean value. Here is an example of a very
procedural loop:

[[[testcase=true
n := 1.
[ n < 1000 ] whileTrue: [ n := n*2 ].
n
>>> 1024
]]]

==whileFalse:== reverses the exit condition.

[[[testcase=true
n := 1.
[ n > 1000 ] whileFalse: [ n := n*2 ].
n
>>> 1024
]]]

==timesRepeat:== offers a simple way to implement a fixed iteration:

[[[testcase=true
n := 1.
10 timesRepeat: [ n := n*2 ].
n
>>> 1024
]]]

We can also send the message ==to:do:== to a number which then acts as the
initial value of a loop counter. The two arguments are the upper bound, and a
block that takes the current value of the loop counter as its argument:

[[[testcase=true
result := String new.
1 to: 10 do: [:n | result := result, n printString, ' '].
result
>>> '1 2 3 4 5 6 7 8 9 10 '
]]]

!!! High-order iterators
Collections comprise a large number of different
classes, many of which support the same protocol. The most important messages
for iterating over collections include ==do:==, ==collect:==, ==select:==,
==reject:==, ==detect:== and ==inject:into:==. These messages define high-level
iterators that allow one to write very compact code.

An ""Interval"" is a collection that lets one iterate over a sequence of numbers
from the starting point to the end. ==1 to: 10== represents the interval from 1
to 10. Since it is a collection, we can send the message ==do:== to it. The
argument is a block that is evaluated for each element of the collection.

[[[testcase=true
result := String new.
(1 to: 10) do: [:n | result := result, n printString, ' '].
result
>>> '1 2 3 4 5 6 7 8 9 10 '
]]]

==collect:== builds a new collection of the same size, transforming each
element. (You can think of ==collect:== as the Map in the MapReduce
programming model).

[[[testcase=true
(1 to:10) collect: [ :each | each * each ]
>>> #(1 4 9 16 25 36 49 64 81 100)
]]]

==select:== and ==reject:== build new collections, each containing a subset of
the elements satisfying (or not) the boolean block condition.

==detect:== returns the first element satisfying the condition. Don't forget
that strings are also collections (of characters), so you can iterate over all
the characters.

[[[testcase=true
'hello there' select: [ :char | char isVowel ]
>>> 'eoee'
]]]
[[[testcase=true
'hello there' reject: [ :char | char isVowel ]
>>> 'hll thr'
]]]
[[[testcase=true
'hello there' detect: [ :char | char isVowel ]
>>> $e
]]]

Finally, you should be aware that collections also support a functional-style
fold operator in the ==inject:into:== method. You can also think of it as the
Reduce in the MapReduce programming model. This lets you generate a cumulative
result using an expression that starts with a seed value and injects each
element of the collection. Sums and products are typical examples.

[[[testcase=true
(1 to: 10) inject: 0 into: [ :sum :each | sum + each]
>>> 55
]]]

This is equivalent to ==0\+\1\+2\+3\+4\+5\+6\+7\+8\+9\+10==.

More about collections can be found in Chapter
*: Collections>../Collections/Collections.pier@cha:collections*.

!!! Primitives and pragmas

In Pharo everything is an object, and everything happens by sending messages.
Nevertheless, at certain points we hit rock bottom. Certain objects can only get
work done by invoking virtual machine primitives.

For example, the following are all implemented as primitives: memory allocation
(==new==, ==new:==), bit manipulation (==bitAnd:==, ==bitOr:==, ==bitShift:==),
pointer and integer arithmetic (\+, \-, \<, \>, \*, \/, \=, \=\=...), and
array access (==at:==, ==at:put:==).

Primitives are invoked with the syntax ==<primitive: aNumber>==. A method that
invokes such a primitive may also include Pharo code, which will be
executed only if the primitive fails.

Here we see the code for ==SmallInteger>>+==. If the primitive fails, the
expression ==super + aNumber== will be executed and returned.

[[[
+ aNumber
	"Primitive. Add the receiver to the argument and answer with the result
	if it is a SmallInteger. Fail if the argument or the result is not a
	SmallInteger Essential No Lookup. See Object documentation whatIsAPrimitive."

	<primitive: 1>
	^ super + aNumber
]]]

In Pharo, the angle bracket syntax is also used for method annotations called pragmas.

!!!Chapter summary

- Pharo has only six reserved identifiers (also called pseudo-variables): ==true==, ==false==, ==nil==, ==self==, ==super==, and ==thisContext==.
- There are five kinds of literal objects: numbers (5, 2.5, 1.9e15, 2r111), characters (==$a==), strings (=='hello'==), symbols (==#hello==), and arrays (==#('hello' #hi)== or =={ 1 . 2 . 1 + 2 }== )
- Strings are delimited by single quotes, comments by double quotes. To get a quote inside a string, double it.
- Unlike strings, symbols are guaranteed to be globally unique.
- Use ==#( ... )== to define a literal array at compile time. Use =={ ... }== to define a dynamic array at runtime. Note that ==#(1+2) size >>> 3==, but =={12+3} size >>> 1==.  To observe why, compare ==#(12+3) inspect== and =={1+2} inspect==.
- There are three kinds of messages: unary (e.g., ==1 asString==, ==Array new==), binary (e.g., ==3 \+ 4==, =='hi', ' there'==), and keyword (e.g., =='hi' at: 2 put: $o==)
- A cascaded message send is a sequence of messages sent to the same target, separated by semi-colons: ==OrderedCollection new add: #calvin; add: #hobbes; size >>> 2==
- Local variables are declared with vertical bars. Use ==:= == for assignment. ==\|x\| x := 1 ==
- Expressions consist of message sends, cascades and assignments, evaluated left to right (and optionally grouped with parentheses). Statements are expressions separated by periods.
- Block closures are expressions enclosed in square brackets. Blocks may take arguments and can contain temporary variables. The expressions in the block are not evaluated until you send the block a value message with the correct number of arguments. ==[ :x | x + 2 ] value: 4==
- There is no dedicated syntax for control constructs, just messages that conditionally evaluate blocks.
