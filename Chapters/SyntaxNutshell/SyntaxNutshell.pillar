!!Sintaksa ukratko
@cha:syntax

Pharo je usvojio sintaksu koja je veoma bliska sintaksi njenog prethodnika, Smalltalk-a. Sintaksa je dizajnirana tako da tekst može biti pročitan naglas tako da zvuči skoro kao Engleski. Sledeći metod klase ==Week== prikazuje primer sintakse. On proverava da li ==DayNames== već sadrži argument, tj.
da li argument predstavlja ispravno ime dana. Ako je to slučaj, dodeliće ga promenljivoj ==StartDay==.

[[[
startDay: aSymbol

   (DayNames includes: aSymbol)
      ifTrue: [ StartDay := aSymbol ]
      ifFalse: [ self error: aSymbol, ' is not a recognised day name' ]
]]]

Pharo sintaksa je minimalna. U suštini, postoji samo sintaksa za slanje poruka
(tj. izrazi). Izrazi se grade od veoma malog broja primitivnih elemenata (slanje poruka, dodela, zatvaranje bloka (''eng. block closure''), vraćanje (''eng. return''),... Postoji samo 6 klučnih reči, takozvanih pseudo-promenljivih i ne postoji sintaksa za kontrolne strukture ili declarisanje novih klasa. Umesto toga, skoro sve se postiže slanjem poruka objektima. Na primer, umesto if-then-else kontrolne strukture, uslovni izrazi su poruke (kao što je ==ifTrue:==) poslate objektima klase Boolean. Nove (pod-)klase se kreiraju slanjem poruke njihovim superklasama.

!!!Elementi sintakse

Izrazi se grade od sledećih  elemenata:

# Šest ''pseudo-promenljivih'': ==self==, ==super==, ==nil==, ==true==, ==false==, i ==thisContext==
# Konstantni izrazi za ''literale'', konkretne objekte, uključujući brojeve, karaktere, stringove, simbole i nizove
# Deklaracije promenljivih
# Dodele
# Zatvaranja blokova
# Poruke
# Vraćanje rezultata iz metoda

Pogledajmo primere različitih elemenata sintakse u tabeli ispod.

|!Sintaksni izraz |!Šta predstavlja
|==startPoint== | ime promenljive
|==Transcript== | ime globalne promenljive
|self | pseudo-promenljiva
|==1 ==| decimali ceo broj
|==2r101== | binarni ceo broj
|==1.5== | broj sa plivajućom tačkom
|==2.4e7== | broj u exponencialnoj notaciji
|==$a== | karakter =='a'==
|=='Hello'== | string =='Hello'==
|==#Hello== | simbol ==#Hello==
|==#(1 2 3)== | literal niz
|=={ 1 . 2 . 1 + 2 }== | dinamički niz
|=="a comment"== | komentar
|==\| x y \|==| deklaracija promenljivih ==x== i ==y==
|==x := 1==| dodela: 1 dodeljuje promenljivoj ==x==
|==[:x \| x + 2 ]==| blok čija je vrednost ==x + 2==
|==<primitive: 1>==| primitivne operacije vitruelne mašine ili anotacije
|==3 factorial==| unarna poruka ==factorial==
|==3 + 4==| binarna poruka ==+==
|==2 raisedTo: 6 modulo: 10==| poruka sa ključnim rečima ==raisedTo:modulo:==
|==^ true==| vraća vrednost true
|==x := 2 . x := x + x==| dva izaza razdvojena separatorom (==.==)
|==Transcript show: 'hello'; cr==| dve kaskadne poruke razdvojene separatorom (==;==)

""Localne promenljive."" ==startPoint== je ime promenljive, ili identifikator. Prema konvenciji, identifikatori su sastavljeni od reči  u ''camelCase'' formatu (tj. svaka reč izuzev prve počinje velikim slovom). Prvo slovo promenljive instance, parametra metoda ili bloka, ili privremene promenljive mora biti malo slovo. Ovo ukazuje čitaocu da promenjlive imaju privatan opseg vidljivosti.

""Deljene promenljive."" Identifikatori koji počinju velikim slovom letters su globalne promenljive, promenljive klase, objedinjeni rečnik ili imena klasa. ==Transcript== je globalna promenljiva, instanca klase ==ThreadSafeTranscript==.

""Aktuelni objekat."" ==self== je pseudo-promenljiva koja se odnosi na tekući objekat i daje nam način da mu pošaljemo poruku. Kako je tekući objekat onaj unutar kog se trenutni metod izvršava, možemo ga zvati i ''primaoc'' jer će ovaj objekat primiti poruku što će dovesti do izvršavanja metoda. Konačno, ==self== se zove ''pseudo-promenljiva'' jer mu ne možemo dodeliti vrednost.

""Celi brojevi."" ''(eng. Integers.)'' Pored uobičajenih decimalnih celih brojeva kao što je 42, u Pharo-u možemo koristiti i ''radix'' notaciju. ==2r101== je 101 sa osnovom 2 (tj., binarno), što je jednako decimalnom 5.

""Brojevi sa plivajućom tačkom."" mogu biti zapisani eksponencijalno sa osnovom 10: ==2.4e7== je ==2.4 X 10^7==.

""Karakteri."" Znak za dolar, ==$==, uvodi literal karakter: ==$a== je literal za karakter =='a'==. Instance specijalnih karaktera koji se ne štampaju mogu biti pribavljene slanjem odgovarajućih, prigodno imenovanih poruka, kao što su ==Character space== i ==Character tab==, klasi ==Character==.

""Stringovi."" Jednostruki navodnici ==' '== se koriste za definisanje string literala. Ao želite string koji sadrži jednostruke navodnike u sebi, samo duplirajte navodnik, kao u
=='G'\'day'==.

""Simboli."" Simboli su kao Stringovi, u smislu da predstavljaju sekvencu karaktera. HIpak, za razliku od stringova, simbol literali su garantovano jedinstveni na globalnom nivou. Postoji samo jedan objekat  ==#Hello== klase ==Symbol==, dok može postojati više objekata klase ==String== koji imaju vrednost =='Hello'==.

""Nizovi literali u vreme kompajliranja."" Definišu se sa ==#( )== unutar čega su navedeni literali razdvojeni razmakom. Sve unutar zagrada mora biti konstanta u vreme kompajliranja. Na primer, ==#(27 (true false) abc)== je niz literal sa tri elementa: ceo broj 27, literalni niz koji sadrži dve pseudo-promenljive, nepromenljive objekte klase Boolean, i simbol ==#abc==. Primetimo da je ovo isto kao ==#(27 #(true false) #abc)==.

""Dinamički nizovi u vreme izvršavanja."" Vitičaste zagrade =={ }== definišu dinamičke nizove čiji se elementi su izrazi odvojeni tačkom i koji se izračunavaju u vreme izvršavanja. Dakle,  =={ 1. 2. 1 + 2 }== definiše niz čiji su elementi 1, 2, i rezultat izračunavanja ==1+2==.

""Komentari."" Navode se unutar dvostrukih navodnika \" \". =="Hello"== je komentar,a ne String, i ignoriše se od strane Pharo compajlera. Komentari se mogu prostirati preko više linija.

""Definicije lokalnih promenljivih."" Vertikalne crte ==| |== ograničavaju definiciju jedne ili više lokalnih promenljivih pre početka tela metoda ili bloka.

""Dodela."" ==:= == dodeljuje objekat promenljivoj.

""Blokovi."" Unutar uglastih zagrada ==[ ]== definišemo blokove, koji su takođe poznati kao zatvaranje bloka ''eng. block
closure'' ili leksičko zatvaranje ''eng. lexical closure''. To su objekti prve klase koji predstavljaju funkcije. Kao što ćemo videti, blokovi mogu imati argumente (==[:i | ...]==) i lokalne promenljive (==[| x | ...]==) .

""Primitivne operacije."" ==< primitive: ... >== označava  poziv primitivne operacije virtuelne mašine (VM). Na primer, ==< primitive: 1 >== je primitivna operacija VM za ==SmallInteger==. Bilo koji kod koji sledi iza primitivne operacije izvršava se samo ako primitivna operacija ne uspe. Ista sintaksa poruke unutar ==< >== se takođe koristi za druge vrste anotacije metoda (''eng. pragma'').

""Unarne poruke."" One se satoje od samo jedne reči (kao što je ==factorial==) poslate primaocu (kao što je 3). U ==3 factorial==, 3 je primaoc, a ==factorial== je selektor poruke.

""Binarne poruke."" To su poruke koje se šalju primaocu sa samo jednim argumentom i čiji selektor izgleda kao matematički operator (na primer: ==\+==). U ==3 + 4==, primaoc je 3, selector poruke je ==\+==, a argument je 4.

""Poruke sa ključnim rečima."" Njihov selektor se sastoji od jedne ili više ključnih reči (npr. ==raisedTo:modulo:==), od kojih se svaka završava s advotačkom i uzima tačno argument. U izrazu ==2 raisedTo: 6 modulo: 10==, selektor poruke
==raisedTo:modulo:== prima dva argumenta, 6 i 10, od kojih se svaki navodi iza odgovarajuće dvotačke. Ova poruka se šalje primaocu 2.

""Sekvenca naredbi."" Tačka (==.==) je separator naredbi. Stavljanjem tačke izmedju dva izraza učiniće ih nezavisnim naredbama kao u ==x := 2. x := x + x== gde u prvom izrazu promenljivoj ==x== dodeljujemo vrednost 2, a zatim njenu vrednost dupliramo dodeljujući joj vrednost zbira ==x + x==.

""Kaskade."" Tačka-zarez ( ==;== ) se može koristiti da se pošalje kaskada poruka jednom primaocu. U  ==stream nextPutAll: ’Hello World’; close== prvo primaocu ==stream== šaljemo poruku sa ključnim rečima
 ==nextPutAll: ’Hello World’== , a zatim istom primaocu šaljemo unarnu poruku ==close==.

""Vraćanje vrednosti izračunavanja metoda."" ==^== se koristi da ''vrati'' vrednost iz metoda.

Osnovne klase ==Number==, ==Character==, ==String== i ==Boolean== opisane su u Glavi *: Osnovne klase>../BasicClasses/BasicClasses.pier@cha:basicClasses*.

!!!Pseudo-promenljive

U Pharo-u, postoji 6 rezervisanih ključnih reči, ili pseudo-promenljivih: ==nil==, ==true==, ==false==, ==self==, ==super==, and ==thisContext==. Zovemo ih pseudo-promenljivim jer su one predefinisane i ne može in se dodeliti vrednost.
==true==, ==false==, i ==nil== su konstante, dok se vrednost ==self==, ==super==, i ==thisContext== menja dinamički u toku izvršavanja programa.

- ==true== i ==false== su jedinstvene instance klasa  ==True== i ==False== koje su podklase klase ==Boolean==. Pogledati Glavu *: Osnovne klase>../BasicClasses/BasicClasses.pier@cha:basicClasses* za više detalja.

- ==self== se uvek referencira na primaoca poruke i označava objekat u okviru kog će se odgovarajući metod izvršiti. Zbog toga se vrednost pseudo-promenljive ==self== dinamički menja u toku izvršavanja programa, ali joj ne može biti dodeljena vrednost u kodu.

- ==super== se takođe referencira na primaoca tekuće poruke, ali kada se pošalje poruka primaocu ==super==, odgovarajući metod koji će se izvršiti se traži počevši od super klase klase koja sadrži metod u kom se šalje poruka primaocu ==super==. Za više detalja pogledajte Glavu *: Pharo Objektni Model>../PharoObjectModel/PharoObjectModel.pier@cha:model*.

- ==nil== is the undefined object. It is the unique instance of the class ==UndefinedObject==. Instance variables, class variables and local variables are initialized to ==nil==.

- ==thisContext== is a pseudo-variable that represents the top frame of the execution stack. ==thisContext== is normally not of interest to most programmers, but it is essential for implementing development tools like the debugger, and it is also used to implement exception handling and continuations.

!!!Slanje poruka

Kao što smo videli, postoje tri vrste poruka u Pharo-u sa predefinisanim prioritetom. Ova razlika je napravljena da se smanji broj obaveznih zagrada.
Ovde dajemo kratak pregled vrsta poruka i načine njihovog slanja i izvršavanja, dok se dataljni opis može naći u Glavi *: Razumevanje sintakse poruka>../UnderstandingMessage/UnderstandingMessage.pier@chapterUnderstandingMessage*.


#''Unarne poruke'' ne primaju argumente. ==1 factorial== šalje poruku ==factorial== objektu 1. Selektor unarne poruke sastoji se od alfanumeričkih karaktera i počinje malim slovom.
#''Binarne poruke'' primaju tačno jedan argument. ==1 \+ 2== šalje poruku ==\+== sa argumentom 2 objektu 1. Selektori binarnih poruka sastoje se od jednog ili više karaktera iz sledećeg skupa: ==+ - / \ * ~ < > = @ % | & ? ,==
#''Poruke sa ključnim rečima'' uzimaju proizvoljan broj argumenata. ==2 raisedTo: 6 modulo: 10== šalje poruku čiji je selektor ==raisedTo:modulo:==, a argumenti 6 i 10, objektu 2. Selektori poruka sa ključnim rečima sastoje se od niza alfanumeričkih reči (ključne reči) od kojih svaka počinje malim slovom i završava se dvotačkom.


!!!!Prioritet poruka.
Unarne poruke imaju najviši prioritet, zatim binarne poruke, i konačno poruke sa ključnim rečima.

Tako u narednom primeru prvo šaljemo poruku ==factorial== primaocu 3 što će nam dati rezultat 6. Zatim šaljemo poruku ==+ 6== primaocu 1 što daje rezultat 7, i na kraju šaljemo poruku ==raisedTo: 7== objektu 2. 
[[[testcase=true
2 raisedTo: 1 + 3 factorial
>>> 128
]]]


Ako se izuzme prioritet, poruke iste vrste izvršavaju se strogo sleva na desno. Stoga, kako imamo dve binarne poruke, naredni primer će vratiti 9, a ne 7.
[[[testcase=true
1 + 2 * 3
>>> 9
]]]

Moraju se koristiti zagrade da se izmeni redosled izračunavanja kao što sledi.
[[[testcase=true
1 + (2 * 3)
>>> 7
]]]

!!!Sekvence i kaskade.
Svi izrazi se mogu komponovati u sekvencu upotrebom tačke, dok se slanja poruka mogu komponovati i u kaskade upotrebom tačka-zareza. 
Niz izraza razdvojenih tačkom prouzrokuje da se svaki izraz u nizu evaluira kao nezavisna ''naredba'', jedan za drugim.

[[[
Transcript cr.
Transcript show: 'hello world'.
Transcript cr
]]]

Ovo će poslati poruku ==cr== objektu ==Transcript==, zatim će objektu Transcript poslati poruku ==show: 'hello world'==, i na kraju će mu ponovo poslati ==cr==.
tada se ovo može izraziti sažetije kao ''kaskada''. Primaoc se navodi samo jednom, a poruke koje mu se šalju se navode u nizu razdvojene tačka-zarezom.

[[[
Transcript
  cr;
  show: 'hello world';
  cr
]]]

Ova kaskada ima potpuno isti efekat kao sekvenca u prethodnom primeru.


!!!Sintaksa metoda

Dok se izrazi mogu evaluirati bilo gde u Pharo okruženju (na primer, u plejgraundu (''eng. playground'') u debageru (''eng. debugger''), ili u brauzeru (''eng. browser''), metodi se obično definišu u prozoru brauzera ili u debageru. Metodi se, takođe, mogu učitati sa eksternog medijuma, ali ovo nije uobičajeni način programiranja u Pharo-u.

Programi se razvijaju metod po metod, u kontekstu date klase. Klasa se definiše slanjem poruke postojećoj klasi, tražeći od nje da kreira svoju podklasu, tako da nema specijalne sintakse neophodne za kreiranje klasa.

Sledi metod ==lineCount== definisan u klasi ==String==. Uobičajena ''konvencija'' za navođenje metoda je u obliku ==ClassName>>methodName==.  Tako je ovde metod ==String>>lineCount==. Primetimo da ==ClassName>>methodName== nije deo Pharo sintakse, već samo konvencija korušćena u knjizi za jasnije navođenje metoda u okviru klase u kojoj je definisan.

[[[
String >> lineCount
	"Answer the number of lines represented by the receiver, where every cr adds one line."

	| cr count |
	cr := Character cr.
	count := 1 min: self size.
	self do: [:c | c == cr ifTrue: [count := count + 1]].
	^ count
]]]

Sintaksno, metod se sastoji od:

#paterna metoda, koji sadrži ime (==lineCount==) i proizvoljne parametre (nema parametara u ovom primeru),
#comentare koji se mogu pojaviti bilo gde, ali prema konvenciji navodi se komentar na vrhu metoda da se objasni namena metoda,
#deklaracije lokalnih promenljivih (==cr== i  ==count==), i
#proizvoljan broj izraza razdvojenih tačkom (ovde ih ima četiri)

Izvršavanje bilo kog izraza kom prethodi ==^== (kapica ili strelija na gore, što je na većini tastatura dobija kombinacijom tastera Shift - 6) prouzrokovaće da metod prestane sa izvršavanjem na tom mestu i vrati vrednost izraza koji sledi iza ==^== kao rezultat izvršavanja. Metod koji završava bez eksplicitno navedenog vraćanja vrednosti nekog izraza, implicitno će vratiti objekat ==self==.

Parametri i lokalne promenljive treba uvek da počinju malim slovom. Imena koj apočinju velikim slovom smatraju se globalnim premenljivim. Imena klasa, kao što je na primer ==Character==, su jednostavno globalne promenljive koje referenciraju objekte odgovarajuće klase.

!!!Sintaksa bloka

Blokovi (leksička zatvaranja) obezbeđuju mehanizam da se odloži izračunavanje izraza. Blok je, u suštini, anonimna funkcija sa kontekstom definicije. Blok se izvršava slanjem poruke ==value== istom. Blok odgovara vrednošću poslednjeg izraza u svom telu, osim u slučaju kada postoji ekspicitno vraćanje vrednosti (upotrebom ==^==) u kom slučaju vraća vrednost izraza iza ==^==.

[[[testcase=true
[ 1 + 2 ] value
>>> 3
]]]


[[[testcase=true
[ 3 = 3 ifTrue: [ ^ 33 ]. 44 ] value
>>> 33
]]]

Blocks may take parameters, each of which is declared with a leading colon. A
vertical bar separates the parameter declaration(s) from the body of the block.
To evaluate a block with one parameter, you must send it the message value: with
one argument. A two-parameter block must be sent ==value:value:==, and so on, up
to 4 arguments.

[[[testcase=true
[ :x | 1 + x ] value: 2
>>> 3
]]]

[[[testcase=true
[ :x :y | x + y ] value: 1 value: 2
>>> 3
]]]

If you have a block with more than four parameters, you must use
==valueWithArguments:== and pass the arguments in an array. (A block with a
large number of parameters is often a sign of a design problem.)

Blocks may also declare local variables, which are surrounded by vertical bars,
just like local variable declarations in a method. Locals are declared after any
arguments:

[[[testcase=true
[ :x :y |
	| z |
	z := x + y.
	z ] value: 1 value: 2
>>> 3
]]] 

Blocks are actually lexical closures, since they can refer to variables of the
surrounding environment. The following block refers to the variable ==x== of its
enclosing environment:

[[[testcase=true
| x |
x := 1.
[ :y | x + y ] value: 2
>>> 3
]]]

Blocks are instances of the class ==BlockClosure==. This means that they are
objects, so they can be assigned to variables and passed as arguments just like
any other object.

!!!Conditionals and loops in a nutshell

Pharo offers no special syntax for control constructs. Instead, these are
typically expressed by sending messages to booleans, numbers and collections,
with blocks as arguments.


!!!Some conditionals
Conditionals are expressed by sending one of the messages ==ifTrue:==,
==ifFalse:== or ==ifTrue:ifFalse:== to the result of a boolean expression. See
Chapter *: Basic Classes>../BasicClasses/BasicClasses.pier@cha:basicClasses*,
for more about booleans.

[[[testcase=true
(17 * 13 > 220)
	ifTrue: [ 'bigger' ]
	ifFalse: [ 'smaller' ]
>>>'bigger'
]]]

!!!Some loops
Loops are typically expressed by sending messages to blocks, integers or
collections. Since the exit condition for a loop may be repeatedly evaluated, it
should be a block rather than a boolean value. Here is an example of a very
procedural loop:

[[[testcase=true
n := 1.
[ n < 1000 ] whileTrue: [ n := n*2 ].
n
>>> 1024
]]]

==whileFalse:== reverses the exit condition.

[[[testcase=true
n := 1.
[ n > 1000 ] whileFalse: [ n := n*2 ].
n
>>> 1024
]]]

==timesRepeat:== offers a simple way to implement a fixed iteration:

[[[testcase=true
n := 1.
10 timesRepeat: [ n := n*2 ].
n
>>> 1024
]]]

We can also send the message ==to:do:== to a number which then acts as the
initial value of a loop counter. The two arguments are the upper bound, and a
block that takes the current value of the loop counter as its argument:

[[[testcase=true
result := String new.
1 to: 10 do: [:n | result := result, n printString, ' '].
result
>>> '1 2 3 4 5 6 7 8 9 10 '
]]]

!!!High-order iterators
Collections comprise a large number of different
classes, many of which support the same protocol. The most important messages
for iterating over collections include ==do:==, ==collect:==, ==select:==,
==reject:==, ==detect:== and ==inject:into:==. These messages define high-level
iterators that allow one to write very compact code.

An ""Interval"" is a collection that lets one iterate over a sequence of numbers
from the starting point to the end. ==1 to: 10== represents the interval from 1
to 10. Since it is a collection, we can send the message ==do:== to it. The
argument is a block that is evaluated for each element of the collection.

[[[testcase=true
result := String new.
(1 to: 10) do: [:n | result := result, n printString, ' '].
result
>>> '1 2 3 4 5 6 7 8 9 10 '
]]]

==collect:== builds a new collection of the same size, transforming each
element. (You can think of ==collect:== as the Map in the MapReduce
programming model).

[[[testcase=true
(1 to:10) collect: [ :each | each * each ]
>>> #(1 4 9 16 25 36 49 64 81 100)
]]]

==select:== and ==reject:== build new collections, each containing a subset of
the elements satisfying (or not) the boolean block condition.

==detect:== returns the first element satisfying the condition. Don't forget
that strings are also collections (of characters), so you can iterate over all
the characters.

[[[testcase=true
'hello there' select: [ :char | char isVowel ]
>>> 'eoee'
]]]
[[[testcase=true
'hello there' reject: [ :char | char isVowel ]
>>> 'hll thr'
]]]
[[[testcase=true
'hello there' detect: [ :char | char isVowel ]
>>> $e
]]]

Finally, you should be aware that collections also support a functional-style
fold operator in the ==inject:into:== method. You can also think of it as the
Reduce in the MapReduce programming model. This lets you generate a cumulative
result using an expression that starts with a seed value and injects each
element of the collection. Sums and products are typical examples.

[[[testcase=true
(1 to: 10) inject: 0 into: [ :sum :each | sum + each]
>>> 55
]]]

This is equivalent to ==0\+\1\+2\+3\+4\+5\+6\+7\+8\+9\+10==.

More about collections can be found in Chapter
*: Collections>../Collections/Collections.pier@cha:collections*.

!!!Primitives and pragmas

In Pharo everything is an object, and everything happens by sending messages.
Nevertheless, at certain points we hit rock bottom. Certain objects can only get
work done by invoking virtual machine primitives.

For example, the following are all implemented as primitives: memory allocation
(==new==, ==new:==), bit manipulation (==bitAnd:==, ==bitOr:==, ==bitShift:==),
pointer and integer arithmetic (\+, \-, \<, \>, \*, \/, \=, \=\=...), and
array access (==at:==, ==at:put:==).

Primitives are invoked with the syntax ==<primitive: aNumber>==. A method that
invokes such a primitive may also include Pharo code, which will be
executed only if the primitive fails.

Here we see the code for ==SmallInteger>>+==. If the primitive fails, the
expression ==super + aNumber== will be executed and returned.

[[[
+ aNumber
	"Primitive. Add the receiver to the argument and answer with the result
	if it is a SmallInteger. Fail if the argument or the result is not a
	SmallInteger Essential No Lookup. See Object documentation whatIsAPrimitive."

	<primitive: 1>
	^ super + aNumber
]]]

In Pharo, the angle bracket syntax is also used for method annotations called pragmas.

!!!Chapter summary

- Pharo has only six reserved identifiers (also called pseudo-variables): ==true==, ==false==, ==nil==, ==self==, ==super==, and ==thisContext==.
- There are five kinds of literal objects: numbers (5, 2.5, 1.9e15, 2r111), characters (==$a==), strings (=='hello'==), symbols (==#hello==), and arrays (==#('hello' #hi)== or =={ 1 . 2 . 1 + 2 }== )
- Strings are delimited by single quotes, comments by double quotes. To get a quote inside a string, double it.
- Unlike strings, symbols are guaranteed to be globally unique.
- Use ==#( ... )== to define a literal array at compile time. Use =={ ... }== to define a dynamic array at runtime. Note that ==#(1+2) size >>> 3==, but =={12+3} size >>> 1==.  To observe why, compare ==#(12+3) inspect== and =={1+2} inspect==.
- There are three kinds of messages: unary (e.g., ==1 asString==, ==Array new==), binary (e.g., ==3 \+ 4==, =='hi', ' there'==), and keyword (e.g., =='hi' at: 2 put: $o==)
- A cascaded message send is a sequence of messages sent to the same target, separated by semi-colons: ==OrderedCollection new add: #calvin; add: #hobbes; size >>> 2==
- Local variables are declared with vertical bars. Use ==:= == for assignment. ==\|x\| x := 1 ==
- Expressions consist of message sends, cascades and assignments, evaluated left to right (and optionally grouped with parentheses). Statements are expressions separated by periods.
- Block closures are expressions enclosed in square brackets. Blocks may take arguments and can contain temporary variables. The expressions in the block are not evaluated until you send the block a value message with the correct number of arguments. ==[ :x | x + 2 ] value: 4==
- There is no dedicated syntax for control constructs, just messages that conditionally evaluate blocks.
